"""
This file contains the Parser class implementation.
"""
from tokenizer import Token, TokenType, Tokenizer


class Parser:
    """
    This class represents a parser.
    This step takes the sequence of tokens built in step 1 and checks that the sequence meets
    the syntactical rules of regular arithmetic expressions. If there are no errors,
    the output of this process is the same sequence of tokens generated by the tokenizer.
    """

    def __init__(self):
        """
        This method initializes the parser.

        Attributes:
        tokens -- the list of tokens (list)
        current_token -- the current token (Token)
        token_index -- the current token index (int)
        """
        self._tokens = []
        self.current_token = None
        self.token_index = -1

    def clean(self):
        """
        This method cleans the parser.
        """
        self._tokens = []
        self.current_token = None
        self.token_index = -1

    @property
    def tokens(self):
        """
        Getter for the tokens.
        """
        return self._tokens

    @tokens.setter
    def tokens(self, token_list: list):
        """
        Setter for the tokens.
        This makes sure that the token list is not empty and that all the elements are tokens.

        Keyword arguments:
        token_list -- the list of tokens (list)
        """
        if len(token_list) == 0:
            raise SyntaxError("Empty formula")
        for item in token_list:
            if not isinstance(item, Token):
                raise SyntaxError("Invalid token")
        self._tokens = token_list
        self.advance()

    def advance(self):
        """
        Advance the current token index and set the current token.
        """
        self.token_index += 1
        if self.token_index < len(self.tokens):
            self.current_token = self.tokens[self.token_index]
        else:
            self.current_token = None

    def parse(self, token_list: list):
        """
        Parse the list of tokens and check the syntactical rules.
        If there are no errors, return the same list of tokens.

        Returns:
        tokens -- the list of tokens (list)
        """
        self.clean()
        self.tokens = token_list  # Set the token list
        self.expression()
        return self.tokens

    def expression(self):
        """
        This method checks the syntactical rules of the expression.
        expression -> term { ( '+' | '-' ) term }
        """
        self.term()
        while self.current_token and self.current_token.value in ('+', '-'):
            self.advance()
            self.term()

    def term(self):
        """
        This method checks the syntactical rules of the term.
        term -> factor { ( '*' | '/' ) factor }
        """
        self.factor()
        while self.current_token and self.current_token.value in ('*', '/'):
            self.advance()
            self.factor()

    def factor(self):
        """
        This method checks the syntactical rules of the factor.
        factor -> NUMBER | '(' expression ')' | FUNCTION '(' expression ')' | CELL_IDENTIFIER
        """
        if self.current_token and self.current_token.type == TokenType.NUMBER:
            self.advance()
        elif self.current_token and self.current_token.type == TokenType.OPENING_PARENTHESIS:
            self.advance()
            self.expression()
            if self.current_token and self.current_token.type == TokenType.CLOSING_PARENTHESIS:
                self.advance()
            else:
                raise SyntaxError("Expected closing parenthesis")

        elif self.current_token and self.current_token.type == TokenType.FUNCTION:  # Function synthax comprobation.
            self.advance()
            # Opening parenthesis comprobation.
            if self.current_token and self.current_token.type == TokenType.OPENING_PARENTHESIS:
                self.advance()
                # FUNC(CELL_IDENTIFIER:CELL_IDENTIFIER) comprobation.
                if self.current_token and self.current_token.type == TokenType.CELL_IDENTIFIER:
                    self.advance()
                    if self.current_token and self.current_token.type == TokenType.COLON:
                        self.advance()
                        if self.current_token and self.current_token.type == TokenType.CELL_IDENTIFIER:
                            self.advance()
                        else:
                            raise SyntaxError("Expected cell identifier")
                    else:
                        raise SyntaxError("Expected colon")
                # FUNC(NUMBER;(NUMBER|CELL_IDENTIFIER)) comprobation. TODO: revisar aquesta comprovaci√≥ cal?
                elif self.current_token and self.current_token.type == TokenType.NUMBER:
                    self.advance()
                    if self.current_token and self.current_token.type == TokenType.SEMICOLON:
                        self.advance()
                        if self.current_token and self.current_token.type == TokenType.CELL_IDENTIFIER:
                            self.advance()
                            if self.current_token and self.current_token.type == TokenType.COLON:
                                self.advance()
                                if self.current_token and self.current_token.type == TokenType.CELL_IDENTIFIER:
                                    self.advance()
                                else:
                                    raise SyntaxError("Expected cell identifier")
                            else:
                                raise SyntaxError("Expected colon")
                        elif self.current_token and self.current_token.type == TokenType.NUMBER:
                            self.advance()
                        else:
                            raise SyntaxError("Expected cell identifier or number")
                    else:
                        raise SyntaxError("Expected semicolon")
                else:
                    raise SyntaxError("Expected cell identifier or number")
                if self.current_token and self.current_token.type == TokenType.CLOSING_PARENTHESIS:
                    self.advance()
                else:
                    raise SyntaxError("Expected closing parenthesis")
            else:
                raise SyntaxError("Expected opening parenthesis")
        elif self.current_token and self.current_token.type == TokenType.CELL_IDENTIFIER:
            self.advance()
        else:
            raise SyntaxError("Invalid factor")


# ======================================================================================================================
# Example usage:
tokenizer = Tokenizer()
parser = Parser()

string_to_parse = "A1 + MAX(9;A1:B2) * (10 - 4)"
tokens = list(tokenizer.tokenize(string_to_parse))
result = parser.parse(tokens)
for token in result:
    print(str(token.value))
print("---------------")
string_to_parse = "AB1 + PROMEDIO(A1:B2) * (D3 - 4) / C3 * P0"
tokens = list(tokenizer.tokenize(string_to_parse))
result = parser.parse(tokens)
for token in result:
    print(str(token.value))